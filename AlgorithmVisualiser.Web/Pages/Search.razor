@page "/search"
@using AlgorithmVisualiser.Web.Algorithms
@using AlgorithmVisualiser.Web.Helpers
@using AlgorithmVisualiser.Web.Models

<PageTitle>Search</PageTitle>

<h1>Search</h1>

<p>Search Algorithms!!!</p>

<button class="btn btn-primary" @onclick="Reset">Reset</button>
<button class="btn btn-primary" @onclick="Bfs">Breadth First Search</button>
<button class="btn btn-primary" @onclick="Dfs">Depth First Search</button>
<button class="btn btn-primary" @onclick="FindPath">Find A Path</button>

@if (_nodes == null)
{
  <p>
    <em>Loading...</em>
  </p>
}
else
{
  <div class="maze">
    @foreach (var node in _nodes)
    {
      @if (_startNode == null)
      {
        <button class="maze-node" @onclick="@(e => SetStartNode(node))"
                style=@node.Style>@node.Value</button>
      }
      else
      {
        <button class="maze-node" @onclick="@(e => SetDestinationNode(node))"
                style=@node.Style>@node.Value</button>
      }

      if (node.Row >= NodeHelper.Max)
      {
        <div class="line-break"></div>
      }
    }
  </div>
}

@code {
  private GraphNode[]? _nodes;
  private List<(int Column, int Row)>? _directions;
  private GraphNode? _startNode;
  private GraphNode? _destinationNode;
  private bool _hasSearched;
  private Func<Task>? _stateChangedAndDelay; 
  private CancellationTokenSource _cancellationTokenSource; 

  protected override async Task OnInitializedAsync()
  {
    await Task.Delay(500);
    CreateNodes();
    _hasSearched = false;
    _stateChangedAndDelay = async () =>
    {
      StateHasChanged();
      await Task.Delay(25);
    };
    _cancellationTokenSource = new CancellationTokenSource();
  }

  private void CreateNodes()
  {
    _nodes = NodeHelper.Create100GraphNodes();
  }

  private async Task Bfs()
  {
    Guard();
    await BreadthFirstSearch.Execute(_nodes!, _startNode!, _destinationNode!, _stateChangedAndDelay!, _cancellationTokenSource.Token);
    _hasSearched = true;
  }

  private async Task Dfs()
  {
    Guard();
    await DepthFirstSearch.Execute(_nodes!, _startNode!, _destinationNode!, _stateChangedAndDelay!, _cancellationTokenSource.Token);
    _hasSearched = true;
  }
  
  private async Task FindPath()
  {
    Guard();
    if(!_hasSearched) return;
    await SearchPathFinder.Find(_destinationNode, _startNode, _stateChangedAndDelay!, _cancellationTokenSource.Token);
  }

  private void Guard()
  {
    if (_nodes is null)
    {
      throw new NullReferenceException("Nodes is null.");
    }
    if (_startNode is null)
    {
      throw new NullReferenceException("Start node is null.");
    }
    if (_destinationNode is null)
    {
      throw new NullReferenceException("Destination node is null.");
    }
    if(_stateChangedAndDelay is null) 
    {
      throw new NullReferenceException("StateChangedAndDelay function is null.");
    }
  }

  private void SetStartNode(GraphNode startNode)
  {
    _startNode = startNode;
    _startNode.AddStartNodeStyle();
    _startNode.SetStart();
    StateHasChanged();
  }

  private void SetDestinationNode(GraphNode destinationNode)
  {
    _destinationNode?.Reset();
    if (_destinationNode != null &&
        _destinationNode?.Value == destinationNode.Value)
    {
      _destinationNode = null;
      return;
    }
    _destinationNode = destinationNode;
    destinationNode.AddDestinationNodeStyle();
    destinationNode.SetDestination();
    StateHasChanged();
  }

  private void Reset()
  {
    _startNode?.Reset();
    _destinationNode?.Reset();
    _startNode = null;
    _destinationNode = null;
    _hasSearched = false;
    _cancellationTokenSource.Cancel();

    if (_nodes == null) return;

    foreach (var node in _nodes)
    {
      node.Reset();
    }
    StateHasChanged();
    _cancellationTokenSource.Dispose();
    _cancellationTokenSource = new CancellationTokenSource();
  }
}