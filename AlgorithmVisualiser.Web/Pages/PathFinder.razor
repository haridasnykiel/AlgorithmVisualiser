@page "/path-finder"
@using AlgorithmVisualiser.Web.Helpers
@using AlgorithmVisualiser.Web.Models
<h3>PathFinder</h3>

<button class="btn btn-primary" @onclick="Reset">Reset</button>
<button class="btn btn-primary" @onclick="RunDijkstra">Dijkstra</button>

@if (_nodes == null)
{
  <p>
    <em>Loading...</em>
  </p>
}
else
{
  <div class="maze">
    @foreach (var node in _nodes)
    {
      @if (_startNode == null)
      {
        <button class="maze-node" @onclick="@(e => SetStartNode(node))"
                style=@node.Style>@node.Value W @node.Weight</button>
      }
      else
      {
        <button class="maze-node" @onclick="@(e => AddDestinationNode(node))"
                style=@node.Style>@node.Value W @node.Weight</button>
      }

      if (node.Row >= NodeHelper.MaxRow)
      {
        <div class="line-break"></div>
      }
    }
  </div>
}

@code {

  private GraphNode[]? _nodes;
  private GraphNode? _startNode;
  private HashSet<GraphNode>? _destinationNodes;
  private CancellationTokenSource? _cancellationTokenSource;

  protected override async Task OnInitializedAsync()
  {
    await Task.Delay(500);
    CreateNodes();
    _cancellationTokenSource = new CancellationTokenSource();
  }

  private void SetStartNode(GraphNode startNode)
  {
    _startNode = startNode;
    _startNode.AddStartNodeStyle();
    _startNode.SetStart();
    StateHasChanged();
  }

  private void CreateNodes()
  {
    _nodes = NodeHelper.Create100GraphNodes();
    _destinationNodes = new HashSet<GraphNode>();
  }

  private void AddDestinationNode(GraphNode destinationNode)
  {
    if(_destinationNodes is null) return;
    if (!_destinationNodes.Add(destinationNode))
    {
      destinationNode.Reset();
      _destinationNodes.Remove(destinationNode);
      return;
    }

    destinationNode.AddDestinationNodeStyle();
    destinationNode.SetDestination();
    StateHasChanged();
  }

  private async Task<string> RunDijkstra()
  {
    if (_cancellationTokenSource.IsCancellationRequested)
    {
      _cancellationTokenSource.Dispose();
      _cancellationTokenSource = new CancellationTokenSource();
    }
    if (_nodes == null || _startNode == null || _destinationNodes == null) return string.Empty;
    var result = await Dijkstra(_nodes, _startNode, _destinationNodes.ToList());
    var weightSum = 0;
    foreach (var node in result)
    {
      weightSum += node.Weight;
    }

    return weightSum.ToString();
  }


  private async Task<GraphNode[]> Dijkstra(GraphNode[] nodes, GraphNode source, List<GraphNode> pins)
  {
    if (_nodes is null)
    {
      return [];
    }

    var visited = new bool[_nodes.Length];
    var previous = new int[_nodes.Length];
    var distances = new int[_nodes.Length];

    for (int i = 0; i < _nodes.Length; i++)
    {
      distances[i] = int.MaxValue;
      previous[i] = -1;
      visited[i] = false;
    }

    distances[int.Parse(source.Value) - 1] = 0;
    while (visited.Any(v => !v))
    {
      if (_cancellationTokenSource != null && _cancellationTokenSource.IsCancellationRequested) break;
      var smallestUnvisitedEdge = await GetSmallestUnvisitedEdge(nodes, visited, distances);
      if (smallestUnvisitedEdge is null) continue;
      var idx = int.Parse(smallestUnvisitedEdge.Value) - 1;
      visited[idx] = true;
      await SetStyleIfNotStartOrDestination(smallestUnvisitedEdge, async () =>
      {
        smallestUnvisitedEdge.AddVisitedStyle();
        await StateChanged();
      });

      foreach (var edge in smallestUnvisitedEdge.Connections)
      {
        if (_cancellationTokenSource != null && _cancellationTokenSource.IsCancellationRequested) break;
        if (edge is null) continue;
        var edgeIdx = int.Parse(edge.Value) - 1;
        if (visited[edgeIdx]) continue;
        var newDist = distances[idx] + edge.Weight;
        if (newDist < distances[edgeIdx])
        {
          distances[edgeIdx] = newDist;
          previous[edgeIdx] = idx;
          await SetStyleIfNotStartOrDestination(edge, () => SetVisitedThenReset(edge));
        }
      }
    }

    var result = new List<GraphNode>();
    for (int i = 0; i < pins.Count; i++)
    {
      var pin = pins[i];
      var pinIdx = int.Parse(pin.Value) - 1;
      while (previous[pinIdx] != -1)
      {
        result.Add(nodes[pinIdx]);
        pinIdx = previous[pinIdx];
        if (!nodes[pinIdx].IsStart && !nodes[pinIdx].IsDestination)
        {
          await SetStyleIfNotStartOrDestination(nodes[pinIdx], async () =>
          {
            nodes[pinIdx].AddPathNodeStyle();
            await StateChanged();
          });
        }
      }
    }

    return result.ToArray();
  }

  private async Task SetVisitedThenReset(GraphNode node)
  {
    node.AddVisitedStyle();
    await StateChanged();
    node.Reset();
    await StateChanged();
  }

  private async Task SetStyleIfNotStartOrDestination(GraphNode node, Func<Task> func)
  {
    if (!node.IsStart && !node.IsDestination)
    {
      await func();
    }
  }

  private async Task<GraphNode?> GetSmallestUnvisitedEdge(GraphNode[] nodes, bool[] visited, int[] distances)
  {
    GraphNode? smallestEdge = null;
    for (int i = 0; i < nodes.Length; i++)
    {
      if (_cancellationTokenSource != null && _cancellationTokenSource.IsCancellationRequested) break;
      var hasVisited = visited[i];
      var distance = distances[i];
      if (hasVisited) continue;
      if (smallestEdge is null || distance < distances[int.Parse(smallestEdge.Value) - 1])
      {
        smallestEdge = nodes[i];
        await SetStyleIfNotStartOrDestination(smallestEdge, () => SetVisitedThenReset(smallestEdge));
      }
    }

    return smallestEdge;
  }

  private void Reset()
  {
    _startNode?.Reset();
    _destinationNodes?.ToList().ForEach(n => n.Reset());
    _startNode = null;
    _destinationNodes = null;
    _cancellationTokenSource?.Cancel();

    if (_nodes == null) return;

    foreach (var node in _nodes)
    {
      node.Reset();
    }

    StateHasChanged();
  }

  private async Task StateChanged()
  {
    StateHasChanged();
    await Task.Delay(25);
  }

}